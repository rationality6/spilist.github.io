---
title:  "[번역] 아주 거대한 (자바스크립트) 어플리케이션을 디자인하기"
tags: [JavaScript, Software Development, Software Design]
---

```
Malte Ubl의 "Designing very large (JavaScript) applications(https://medium.com/@cramforce/designing-very-large-javascript-applications-6e013a3291a3)"의 번역입니다.
이 글의 모든 권리는 원 저작자에게 있습니다. All rights are reserved to the original author.
```



이 글은 호주 JSConf에서의 내 발표 스크립트를 약간 편집한 것이다. [유투브에서 전체 발표를 볼 수 있다](https://www.youtube.com/watch?v=ZZmUwXEiPm4).

![img](https://cdn-images-1.medium.com/max/1600/1*DqvlkOgHSKmp5Tu1eX5mdw.png)*저는 아주 거대한 자바스크립트 앱을 구축해왔습니다.*

안녕하십니까. 저는 아주 거대한 자바스크립트 앱을 구축해왔습니다. 이젠 이런 일을 더이상 하지 않기 때문에, 제가 해온 일을 돌아보면서 무엇을 배웠는지 공유할 좋은 타이밍이라고 생각했습니다. 

어제 학회 파티장에서 맥주를 마시며 질문을 하나 받았는데요. "Malte, 왜 당신이 이 주제에 대해 이야기할 만한 자격이 있다고 생각하나요?" 이 질문에 대답하는 것이 실제로 제 발표에 연관이 있다고 생각하기 때문에, 저 자신에 대해 이야기하는 게 익숙하지는 않지만 해보겠습니다. 

저는 구글에서 자바스크립트 프레임워크를 만들었습니다. 그 프레임워크는 Photos, Sites, Plus, Drive, Play, 검색엔진 등 구글이 제공하는 서비스들에 사용되고 있죠. 개중 몇몇 사이트는 꽤 크고, 당신도 아마 몇 개는 써본 경험이 있으실 겁니다.



![img](https://cdn-images-1.medium.com/max/1600/1*v0r4OVf-RXr9ePakdmv5LQ.png)*저는 React가 좋다고 생각했습니다.*

이 자바스크립트 프레임워크는 오픈소스가 아닙니다. 그 이유는, 이 프레임워크가 React랑 비슷한 때에 나왔고, 제가 "사람들이 선택할 만한 자바스크립트 프레임워크를 또 늘릴 필요가 정말 있을까?"라고 생각했기 때문입니다. 구글은 이미 오픈 소스 자바스크립트 프로젝트를 몇 개 내놓은 상태였고(Angular와 Polymer), 또 하나가 추가되면 사람들이 혼란을 겪으리라 생각했기에, 그냥 우리끼리만 가지고 있자고 결정했습니다. 

하지만 오픈소스가 아니었더라도, 이걸 만든 경험에서 배울 점이 많을 뿐더러 우리가 배운 걸 공유할 가치가 충분히 있다고 생각합니다.



![img](https://cdn-images-1.medium.com/max/1600/1*LL3uYYDMT5uIFRxR_7JxPQ.png)

자, 이제 아주 거대한 앱에 대해, 그리고 그런 앱들이 가지는 공통점에 대해 이야기해봅시다. 우선, 당연히 앱을 개발하는 개발자는 아주 많겠죠. 수십 명일 수도 있고 더 많을 수도 있습니다. 이들은 감정도 있고 다른 사람들과의 사이에 문제도 있을 수 있으며, 이런 점을 당신은 염두에 두어야 합니다.



![img](https://cdn-images-1.medium.com/max/1600/1*WEH24kaBbar8-1gzN_AO3w.png)

팀이 그렇게 크지 않더라도 여러가지 문제가 생길 수 있습니다. 당신이 그 앱을 개발하는 데 꽤 오랜 시간을 투자해왔을 수도 있고, 그 앱을 유지보수하는 첫 번째 사람이 아닐 수도 있고, 모든 컨텍스트를 가지지 않았을 수도 있고, 당신이 완전히 이해하지 못한 무언가가 있을 수도 있고, 팀 내의 누군가는 앱 전반에 대해 이해하지 못하고 있을 수 있습니다. 이런 게 우리가 아주 커다란 앱을 구축할 때 생각해야 할 사항들입니다.



![img](https://cdn-images-1.medium.com/max/1600/1*fzb42X35lNGmkQHhJLhEBQ.png)*트윗: 주니어 엔지니어가 없는 시니어 엔지니어 팀은 그냥 엔지니어 팀과 같다.*

이 자리에서 얘기하고 싶은 또 다른 주제는 커리어입니다. 여기 계신 많은 분들은 스스로가 시니어 엔지니어라고 생각하고 계실 겁니다. 또는, 아직 은 시니어가 안 됐지만 되기를 원하고 있겠죠. 

저는 시니어가 된다는 것의 의미를, 제게 주어지는 거의 모든 문제를 해결할 수 있는 능력이 있는 것으로 생각합니다. 적절한 도구와, 적절한 도메인 지식을 알고 있으니까요. 그리고 또 하나의 중요한 의미는, 주니어 엔지니어가 언젠가 시니어가 될 수 있도록 돕는 것입니다.



![img](https://cdn-images-1.medium.com/max/1600/1*xpRJ1dXHMlFq1V4oDKU__w.png)*주니어 -> 시니어 -> 그 다음은?*

하지만 어느 순간에 우리는 "그럼 그 다음 단계는 뭐지?" 하고 의문을 가지게 됩니다. 시니어가 되고 나면 그 다음은 어디로 가야 할까요? 누군가는 '관리자'라고 대답하겠지만 그게 모두에게 적절한 답은 아닙니다. 모든 사람이 관리자가 될 순 없으니까요. 어떤 사람들은 정말 훌륭한 엔지니어인데, 여생동안 엔지니어로서 일하는 게 안될 게 뭡니까?



![img](https://cdn-images-1.medium.com/max/1600/1*wL5wiTWICj1keue9YZOAhQ.png)*'나'는 '내'가 어떻게 문제를 풀어야 할지 안다.*

저는 시니어의 다음 단계로 가는 길을 제시하고자 합니다. 저는 시니어 엔지니어로서 "나는 내가 어떻게 문제를 풀어야 할지 안다"고 당당히 말할 수 있습니다. 그리고, 제가 어떻게 문제를 풀지 알기 때문에, 저는 다른 사람이 어떻게 문제를 풀지 가르쳐줄 수도 있습니다.



![img](https://cdn-images-1.medium.com/max/1600/1*UyLoKH7y54JAYigVlwCJpQ.png)*'나'는 '다른 사람이' 어떻게 문제를 풀어야 할지 안다.*

따라서 제가 생각하는 시니어 다음 단계는, 스스로 "나는 *다른 사람*이 어떻게 문제를 풀어야 할지 안다"고 당당히 말할 수 있는 것입니다.



![img](https://cdn-images-1.medium.com/max/1600/1*zBBGLRIZw94gp54pspvx-g.png)*나는 API의 선택과 추상화가 다른 사람이 문제를 푸는 데 어떤 영향을 미칠지 예상할 수 있다.*

조금 더 구체적으로 말해보면 이렇습니다. "나는 내가 선택하는 API 또는 내가 프로젝트에 도입한 추상화가, 다른 사람이 문제를 푸는 데 어떤 영향을 미칠지 예상할 수 있다." 저는 이 문장이 내 선택이 앱에 어떤 영향을 미칠 것인지 생각해보게 하는 강력한 개념이 된다고 생각합니다.



![img](https://cdn-images-1.medium.com/max/1600/1*LnDv6Ry0Hq2MaQEARaD8rg.png)*공감하며 앱 만들기.*

이걸 '공감하며 앱 만들기' 라고 부를 수도 있습니다. 당신의 행동 하나하나와 당신이 다른 개발자에게 주는 API 하나하나가, 그들이 소프트웨어를 개발하는 데 어떤 영향을 미칠 것인지 생각해보는 것입니다.



![img](https://cdn-images-1.medium.com/max/1600/1*pnYiZTAfQqsbeS7kVkLe_g.png)*쉬운 수준의 공감.*

다행히 이런 공감은 쉬운 수준에 속합니다. 공감하는 건 일반적으로 어렵고, 공감하며 앱 만들기도 결코 쉽진 않습니다. 하지만 당신히 공감해야 할 사람들은 적어도 소프트웨어 엔지니어일 것입니다. 그들이 당신과 많은 점이 다르더라도 모두 소프트웨어를 개발한다는 공통점이 있습니다. 당신이 경험을 쌓으면 쌓을수록 이런 공감은 더 잘 할 수 있게 됩니다.



![img](https://cdn-images-1.medium.com/max/1600/1*Op0wLWIqwZ-A5iSuWrqtKA.png)*프로그래밍 모델.*

공감에 대해 생각할 때 제가 이야기하고 싶은 아주 중요한 주제는 '프로그래밍 모델'입니다. 프로그래밍 모델은 "API, 라이브러리, 프레임워크, 도구 등 주어진 조건 하에서 사람들이 어떻게 소프트웨어를 개발하는가"를 뜻합니다. 사실 이 발표는 API와 기타 등등에 준 조그마한 변화가 프로그래밍 모델에 어떤 영향을 끼치는지에 대한 이야기입니다.



![img](https://cdn-images-1.medium.com/max/1600/1*zuLA-tH9b8k4i1yfKMScmA.png)

*프로그래밍 모델에 영향을 미치는 예: React, Preact, Redux, NPM에서 가져온 날짜 선택 라이브러리, NPM*

무엇이 프로그래밍 모델에 영향을 끼치는지 몇 가지 예를 들어보죠. 당신이 Angular로 만들어진 프로젝트를 진행 중이고, "이제 이걸 React로 바꿔야겠어"라는 결정을 한다면, 이는 분명 사람들이 소프트웨어를 어떻게 작성하는지에 영향을 줄 겁니다. 하지만 "겨우 가상 DOM 다루는 데 60KB를 쓴다고? Preact로 바꾸자"라는 결정은, (Preact는 API 호환이 되는 라이브러리이기 때문에) 사람들의 소프트웨어 작성 방식을 바꾸지는 않을 것입니다.

그러고 나서 "앱이 너무 복잡해. 앱 동작을 조절하는 뭔가 필요하니 Redux를 쓰자"라는 결정을 내린다면, 이건 영향을 미칩니다. 이제 날짜 선택(Date picker) 기능이 필요해서 npm에 가보니 500개 결과가 있고, 그 중 하나를 골랐다고 칩시다. 무엇을 골랐는지가 정말 중요할까요? 이건 소프트웨어 작성 방식을 변화시키진 않을 겁니다. 그러나 npm이라는 거대한 모듈의 집합을 능숙하게 사용할 줄 안다는 것은 분명 소프트웨어 작성 방식에 지대한 영향을 미칩니다. 물론 이것들은 겨우 몇 가지 예시일 뿐입니다.



![img](https://cdn-images-1.medium.com/max/1600/1*KfcGnWC3WcwBqGYLPiybgw.png)

*코드 분할하기*.

주제를 약간 바꿔서, 거대한 자바스크립트 앱을 사용자에게 배포하려 할 때 공통적으로 가지게 되는 문제에 대해 이야기해봅시다. 그 문제란 앱의 크기가 일정 이상 커지고 나면, 앱을 사용자에게 한꺼번에 전달하고 싶지 않아한다는 것입니다. 그래서 코드 분할 테크닉을 도입하게 됩니다.

코드 분할이란, 앱을 번들(bundle, 코드 뭉치)의 집합으로 정의함을 뜻합니다. 즉 "어떤 사용자는 내 앱의 이 부분만 사용하고, 다른 사용자는 요 부분만 사용한다"는 것을 파악하고, 사용자가 실제로 실행하는 부분만 다운로드될 수 있도록 특정 코드를 묶어놓는 것입니다. 여기까지는 우리 모두가 할 수 있습니다. (자바스크립트 세계의 많은 기능들처럼 코드 분할도 클로저 컴파일러를 통해 만들어졌지만, 코드 분할을 하는 가장 널리 알려진 방법은 웹팩을 이용하는 것입니다. 당신이 초 멋진 RollupJS를 쓰고 있다면, 여기에서도 얼마 전부터 코드 분할을 지원하기 시작했다는 걸 알아두시기 바랍니다.)

코드 분할이 분명 우리 모두가 써야 하는 기술이긴 하지만, 당신의 앱에 이걸 도입하고자 할 때는 몇 가지 고려할 사항이 있습니다. 코드 분할은 프로그래밍 모델에 영향을 미치기 때문입니다.



![img](https://cdn-images-1.medium.com/max/1600/1*vAR8HCbwiwX8bVa0xIsk6g.png)

*동기 -> 비동기.*

코드 분할을 하면, 원래는 동기적으로 작동했던 것들이 비동기화됩니다. 코드 분할을 하기 전까지 당신의 앱은 단순하고 멋졌습니다. 커다란 것 하나만 있었죠. 일단 로드되고 나면 안정적이고, 이해하기 쉽고, 기다릴 필요가 없었습니다. 그러나 코드 분할 이후에는 때때로 "저 번들이 필요해"라며 네트워크를 거쳐야 할 것이고, 이 사실을 염두에 두어야 하기 때문에 앱이 좀더 복잡해집니다.



![img](https://cdn-images-1.medium.com/max/1600/1*DqT7As1rm_M9cxyW1RIW6w.png)

*인간.*

또한, 우리는 사람을 고려하기 시작해야 합니다. 코드 분할을 위해선 번들을 정의해야 하고, 그러려면 언제 번들을 불러올지 생각해야 하죠. 따라서 사람들, 즉 당신 팀의 동료 엔지니어들이 이제 번들에 무엇이 들어가고 언제 그걸 불러올지 결정을 내려야 한다는 게 됩니다. 사람이 연관되게 하는 행동은, 이러한 것들을 고려해야 하기 때문에 언제나 프로그래밍 모델에 분명한 영향을 미칩니다.



![img](https://cdn-images-1.medium.com/max/1600/1*0jNa8A5ciY6pCJCN65vLiA.png)

*경로 기반 코드 분할.*

코드 분할에 있어서 사람을 복잡한 고려사항에서 빼버리는 잘 구축된 방법으로 '경로 기반 코드 분할'이 있습니다. 아직 당신이 코드 분할을 하지 않고 있다면 아마 이 방법이 첫 번째로 시도해보기에 적절할 겁니다. 

경로란 앱에서의 기본적인 URL 구조를 뜻합니다. 예를 들어 당신 앱이 `/product/`라는 경로 아래에 상품 페이지들이 있고, 다른 경로에 카테고리 페이지들이 있다고 해봅시다. 이 때 그냥 각 경로를 하나의 번들로 만들면 앱의 라우터가 코드 분할을 책임지게 됩니다. 사용자가 한 경로에 들어가면 라우터가 관련 번들을 불러올 것이므로, 해당 경로 안에서는 더이상 코드 분할을 신경쓸 필요가 없습니다. 당신은 다시 전체를 번들 하나로 두었던 옛 프로그래밍 모델과 거의 같은 방식으로 생각할 수 있게 되죠. 이와 같이 경로 기반 분할은 코드 분할의 첫 번째 단계로 아주 좋습니다.

안타깝게도 이 발표의 제목은 **아주** 거대한 자바스크립트 앱을 구축하는 것이었습니다. 앱은 너무 커져서 경로 하나하나가 너무 커지면, 경로별로 하나씩 번들을 두는 게 적절치 않게 됩니다. 충분히 커다란 앱의 좋은 예를 하나 보여드리죠.



![img](https://cdn-images-1.medium.com/max/1600/1*ox94bGuhxWXE-OubL7St6w.png)

*"public speaking 101"의 구글 검색 결과.*

저는 이 발표가 다가오면서 어떻게 좋은 연사가 될 수 있을지 알고 싶었고, 이러한 멋진 푸른색 링크 목록을 얻었습니다. 여러분은 이 페이지가 경로 기반 번들에 아주 적절하다고 생각할 수도 있을텐데요.



![img](https://cdn-images-1.medium.com/max/1600/1*P-XiIPnuzq9_KLA1nG-uRA.png)

*"날씨"의 구글 검색 결과.*

캘리포니아의 겨울이 상당히 추웠다는 걸 기억하고 날씨를 검색해보니, 갑자기 완전히 다른 모듈이 나타납니다. 그러니까 이 단순해 보였던 경로가 사실은 더 복잡했다는 것이죠.



![img](https://cdn-images-1.medium.com/max/1600/1*Y7e5LoeBggY01aRkJAiwWA.png)

*"20 미국 달러는 호주 달러로 얼마인가"의 구글 검색 결과.*

그리고 저는 이 학회에 초청되어 미국 - 호주의 달러 환율이 궁금해졌고, 이제는 복잡한 환율 계산 화면이 나타났네요. 이런 식의 전문화된 모듈이 수천 개는 있기 때문에, 이를 번들 하나에 몰아넣으면 용량이 수 메가바이트는 될 것이고, 사용자는 아주 불만족스러울 것입니다.



![img](https://cdn-images-1.medium.com/max/1600/1*qZhd4a0S-CCB5mUiN3fo5Q.png)

*컴포넌트 단위에서의 지연 로딩?*

따라서 경로 기반 코드 분할을 그냥 쓸 수는 없고 다른 방법이 필요합니다. 경로 기반 분할이 좋았던 이유는, 앱을 가장 바깥쪽 단위에서 분할함으로써 그 안쪽에서는 코드 분할을 신경쓸 필요가 없었기 때문입니다. 

저는 단순함을 좋아하니까, 가장 바깥쪽 대신 가장 안쪽에서 분할을 해보면 어떨까요? 웹사이트에 존재하는 모든 컴포넌트 하나하나를 지연 로딩한다고 가정해봅시다. 만약 사용자의 네트워크 대역폭 하나만 생각한다면 아주 효율적인 방법이 되겠죠. 응답시간 측면에서 보면 아주 안 좋겠지만, 적어도 고려할 가치는 충분히 있는 방법입니다.



![img](https://cdn-images-1.medium.com/max/1600/1*Lr2hIk4eH9uU33e77zeSmA.png)

*리액트 컴포넌트는 자식 컴포넌트에 정적으로 의존합니다.*

하지만 예를 들어 당신의 앱이 리액트를 쓴다면 어떻게 될까요. 리액트에서 컴포넌트는 자신의 자식 컴포넌트에 정적으로 의존합니다. 이는 당신이 자식 컴포넌트를 지연 로딩하면 리액트의 작동 방식이 변하게 되고, 프로그래밍 모델이 바뀌게 되고, 상황이 안좋아지게 된다는 뜻입니다.



![img](https://cdn-images-1.medium.com/max/1600/1*SWkk2vyn344qCNCPSIkXPA.png)*ES6의 import 예시.*

당신의 검색 페이지에 환율 계산기를 넣고 싶어졌다고 합시다. import 를 하겠죠? 위 그림은 ES6 모듈을 import 하는 일반적인 방법입니다.



![img](https://cdn-images-1.medium.com/max/1600/1*RxlHaYEav0OaODKYKiUubw.png)

*Loadable 컴포넌트 예시.*

이걸 지연 로딩하고 싶다면 위와 같이 import 방법을 바꿔서 동적인 import를 해야 합니다. 저는 리액트 전문가도 아니고, 동적 import를 하는 수많은 방법이 있겠지만, 확실한 건 이렇게 함으로써 당신의 코드를 작성하는 방식이 달라진다는 것입니다.



![img](https://cdn-images-1.medium.com/max/1600/1*N5AMAbobPjsO_lXCPt9-ZA.png)

*정적 -> 동적.*

상황은 이제 그다지 좋지 않습니다. 정적이었던 것이 동적으로 바뀌었고, 이는 프로그래밍 모델이 변한다는 또다른 신호입니다.



![img](https://cdn-images-1.medium.com/max/1600/1*j9OB_yjli59MZMyIs9V0_A.png)

*무엇을 언제 지연 로딩할 것인지 누가 정하는가?*

당신은 갑자기 "무엇을 언제 지연 로딩할 것인지 누가 정하는지"가 궁금해지기 시작합니다. 이 문제가 앱의 응답속도에 영향을 미치기 때문이죠.



![img](https://cdn-images-1.medium.com/max/1600/1*rsJ-C7ph0BrJiwTjHKv6_w.png)

*정적인가 동적인가?*

사람이 다시 끼어들어서, "정적 import도 있고 동적 import도 있는데 무엇을 언제 사용해야 하는가?"를 결정해야 합니다. 이 결정을 잘못하면, 동적으로 했어야 했던 걸 정적으로 import하면서 같은 번들에 들어가면 안 되는 것들이 들어갑니다. 오랜 기간동안 많은 개발자가 함께 일하다 보면 이런 잘못된 일들이 벌어지게 됩니다.



![img](https://cdn-images-1.medium.com/max/1600/1*QGoX4bYhEAuNjuKwQhQ0hg.png)

*로직과 렌더링을 분리하기.*

이제 구글이 실제로 이 문제를 어떻게 풀었는지, 그리고 좋은 성능과 좋은 프로그래밍 모델을 동시에 가져가는 방법에 대해서 얘기해보겠습니다. 우리는 먼저 컴포넌트를 렌더링 방식에 따라 분할하고, 그 다음 앱 로직에 따라 분할했습니다. 여기서 앱 로직이란, 예를 들어 사용자가 환율을 의미하는 쿼리를 검색했을 때 환율 변환기가 나타나게 하는 등의 동작을 뜻합니다. *(역자 주: 이 부분의 원문이 번역하기 모호하여 원본 유투브 영상을 보고 의역했습니다.)*



![img](https://cdn-images-1.medium.com/max/1600/1*vMskVnAwJgkZmvl4E-8E4Q.png)

*실제로 렌더링되는 로직만 로드한다.*

따라서 특정 컴포넌트에서 사용되는 앱 로직은 컴포넌트가 렌더되었을 때에만 로드됩니다. 이 방식은 보기보다 매우 단순한데, 단순히 서버에서 페이지를 렌더해놓은 다음, 실제로 사용자에게 무언가가 렌더되면 관련된 앱 번들이 다운로드되도록 하면 되기 때문입니다. 즉 로딩이 렌더링에 의해 자동으로 이루어지기 때문에 사람이 생각할 필요가 없어집니다.