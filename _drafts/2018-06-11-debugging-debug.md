---
title: "디버그를 디버깅하기: 디버그라는 단어의 함정"
tags: ["Software Development", "Debugging", "Problem Solving"]
---

오래되고 기능이 많은 레거시 소프트웨어를 관리하는 조직에서, 신규 기능을 추가하기보다는 여기저기서 터져나오는 문제를 해결하는데 시간을 훨씬 많이 쓰게 되는 경우가 있다. 특히 프로젝트 초기에 좋은 시스템 구조가 설계되지 않았거나, 프로젝트 도중 적절한 리팩토링을 거치지 않았거나, 또는 테스트 코드가 마련되지 않은 상태에서 개발이 진행되다 보면 그리 오랜 시간이 지나지 않아 이런 상황이 되기가 쉽다. 이런 조직이 다시 개발 생산성을 높이기 위해서는 문제가 생겼을 때 단순히 그 문제를 빠르게 해결하기보다는 좀더 체계적인 방법으로 디버깅을 해야 한다. 그러면 어떻게 디버깅을 체계적으로 할 수 있을까.

###디버깅은 단순히 버그를 없애는 것이 아니다

[위키피디아](https://en.m.wikipedia.org/wiki/Software_bug)에 따르면 '버그'는 1870년대부터 기계적 결함을 나타내는 용어로 쓰여왔다. 컴퓨터 영역에서는, 1940년대에 초창기의 컴퓨터 [하버드 마크 II](https://en.m.wikipedia.org/wiki/Harvard_Mark_II)가 패널에 나방이 끼는 바람에 오작동한 사건을 기록한 것에서부터 '버그Bug'와 '디버깅Debugging'이라는 용어가 널리 쓰이기 시작했다고 한다.

![The very first recorded computerxbug](https://cdn0.tnwcdn.com/wp-content/blogs.dir/1/files/2013/09/bug.jpg)

*최초로 기록된 컴퓨터 버그.*

나는 이 **디버깅**이라는 단어 자체가 일종의 함정을 지니고 있다고 느낀다. 디버그라는 말을 들었을 때 가장 쉽게 연상되는 뜻은 de + bug, 즉 **버그를 없앤다**는 것이다(실제로 최초의 버그는 패널에 낀 나방을 제거함으로써 해결했을 것이다). 그래서인지 경험이 적은 개발자일수록 디버깅할 때 버그를 없애는 것에만 집중하는 경향을 보이는 듯하다. 존경하는 개발자인 [김정훈](https://wonderer80.github.io/) 님으로부터 몇년 전 이런 얘기를 듣기 전까지 나도 그런 개발자였다. 

> 훌륭한 개발자는 버그를 대하는 태도가 다릅니다. 버그를 만났을 때 일반적인 개발자는 짜증내며 빠르게 고치려고만 합니다. 같은 상황에서, 훌륭한 개발자는 버그를 버그가 생길 수밖에 없었던 근본적 원인을 생각해보고 리팩토링하는 기회로 삼습니다. 

당시 수많은 함수들이 들어있는 `general.js` 에서 이해할 수 없는 문제가 생겨서, `console.log`를 무작정 찍어가며 디버깅하던 나를 보며 말씀하셨던 걸로 기억한다. 결국 찾아낸 내 문제의 원인은 변수명의 오타였다. 정훈님은 오타를 고치는 게 아니라 파일명, 변수명을 비롯한 코드 구조 자체를 바꿔야 한다고 말씀하셨다. 이런 근본적인 문제가 해결되어야 나중에 비슷한 문제가 생길 가능성이 줄어든다면서.

'버그가 생길 수밖에 없었던 근본적 원인을 찾아 개선한다'는 말은 무척 놀라웠고 내 머릿속에 깊이 새겨졌다. 그리고 이 말을 내 안에서 오랫동안 숙성시킴으로써 나만의 디버깅 템플릿을 만들어낼 수 있었다. 이 템플릿은 유저가 리포트한 버그를 고치는 것을 가정하여 만들었지만, '버그'는 결국 '구현한 기능이 의도대로 동작하지 않는다'는 것이고, 따라서 일반적으로 코딩할 때 겪는 문제에 대해서도 적용 가능하다. 디버깅 과정을 **현상**, **문제 원인**, **해결책**, **환경 개선**의 네 단계로 나누는 것에서부터 시작한다.

###1. 현상

현상 단계에서 중요한 것은 사실을 기록하는 것이다. 예를 들어 "A 페이지에서 B 문제가 있어요"라는 리포트를 받았을 때 "어 이거 최근에 배포된 C 때문인 것 같은데요?"와 같이 그 순간 문제 원인이 생각날 수도 있는데, 일단 참고 객관적인 사실만 기록한다.

**1-1. 누가, 어디서, 어떤 문제 현상을 겪었는가?**

예를 들면 웹 프론트엔드 영역에서는 대략 이렇게 바꿀 수 있다. (실제로 문제를 겪은 사람의 리포트 링크, 문제 상황 스크린샷, 에러 로그 등의 데이터는 따로 기록해둔다.)
- 누가: 유저의 권한이 무엇인가?
- 어디서: OS 버전은? 브라우저 버전은? 배포된 앱 버전은? 네트워크 환경은? 어느 페이지에서?
- 문제 현상: 어떤 액션을 수행했는가? 이 때 예상 결과는 무엇이었는가? 실제 결과는?

**1-2. 현상이 발생하는 조건은 무엇인가?**

명확한 재현 조건 없이는 문제가 해결됐음을 확신할 수 없다. 문제 액션을 고정한 채 다른 조건을 바꿔보면서, 문제가 어떨 때 생기고 어떨 때 생기지 않는지를 관찰하며 재현 조건을 찾는다.

- '누가'를 바꿔본다. 다른 권한의 유저에게도 발생하는가?
- '어디서'를 바꿔본다. 다른 OS, 다른 브라우저, 다른 앱 버전에서도 발생하는가? 네트워크 환경이 바뀌면 어떤가? 
- 문제 액션을 실행하기까지의 플로우를 바꿔본다. 문제 액션 이전에 어떤 액션을 했느냐에 따라 앱의 상태가 바뀔 수 있어서이다. 
- 비슷한 액션인데 문제가 발생하지 않는 상황, 그리고 비슷한 문제가 다른 조건에서 발생하는 상황은 없는지 탐색한다.

###2. 문제 원인

**2-1. 코드상에서 문제를 일으키는 부분이 어디인가?** 

이는 재현 조건 찾기의 연장선상에 있다. 문제가 어떨 때 생기고 어떨 때 생기지 않는지를 관찰했듯, 문제를 일으키는 코드를 포착하려면 내 코드에서 어떤 부분이 문제에 영향을 주고 어떤 부분은 영향을 주지 않는지를 알아내야 한다. 재현 조건상에서 문제를 일으키는 액션에 관련된 코드의 범위를 줄여나가면서 정확히 어디가 문제인지 찾는다.

재현 조건이 명확한데도 문제를 일으키는 코드의 위치를 쉽사리 알기 어렵다면 그 자체가 나쁜 코드의 징후다. 대개 적절한 테스트 코드가 없거나 에러 로깅이 잘 되어있지 않을 때 이렇게 된다. 이런 부분은 **환경 개선** 단계에서 해결한다. 

**2-2. 그 코드가, 그 조건에서, 왜 의도대로 동작하지 않았는가?**

코드가 의도대로 동작하지 않은 이유를 이해해야 문제를 근본적으로 해결할 수 있다. 코드의 의도가 명확하지 않다면 이 질문에 답하기 어려울 수 있는데 이 또한 나쁜 코드의 징후다.

**2-3. 파악한 원인으로 인한 다른 문제는 없는가?**

유저가 리포트한 문제는 실제 문제의 한 사례에 불과하다. 문제의 원인에서부터 거꾸로 다른 문제를 탐색해나간다. 의도대로 동작하지 않은 코드가 사용된 다른 부분을 살펴보는 것은 물론이고, 정확히 그 코드는 아니더라도 비슷한 스타일로 작성된 코드가 다른 조건에서 문제를 일으키고 있지는 않은지 확인한다. 이 과정에서 현상 - 문제 해결 단계를 반복하게 될 수도 있다.

###3. 해결책

**3-1. 앱을 의도대로 동작시키려면 어떻게 해야 하는가?**

지금까지 **현상**은 유저 레벨에서 살펴봤고 **문제 원인**은 코드 레벨에서 살펴봤다. 해결책은 현상에 대한 것이 아니라 원인에 대한 해결책이어야 하며, 때론 그 해결책이 코드 레벨이 아니라 유저 레벨에 있을 수도 있다.



**3-2. 그 방법은 다른 방법과 비교했을 때 어떤 장단점이 있는가?**



**3-3. 그 방법이 문제를 완전히 해결함을 어떻게 확신할 수 있는가?**

### 4. 환경 개선

버그가 전혀 없는 앱을 만들어내는 것은 불가능하다. 내 앱에 버그 리포팅이 적다는 것은 실제로 버그가 적은 게 아니라, 유저가 버그를 겪어도 버그인 줄 모르거나, 유저가 버그를 찾아도 리포트하기 어렵거나, 또는 아예 유저가 너무 적다는 의미일 수도 있다. 개발자는 버그가 생길 수밖에 없다는 것을 인정하고, 버그가 생겼을 때 빨리 인지하고 해결할 수 있는 환경을 마련해두어야 한다.

###0. 아직 재현 조건을 / 원인을 / 해결책을 찾지 못한 채 x시간이 지났다면...



###예시: 리사이즈가 안돼요

실제로 직장에서 내가 겪었던 문제에 위 체크리스트를 적용해 보자. 

![debugging-on-debug_resize-01](/Users/spilist/blog/mockups/debugging-on-debug_resize-01.png)

*왼쪽은 좌우 폭을 조절할 수 있는 컴포넌트. 여러 종류의 컨텐츠가 들어갈 수 있는 오른쪽에는 Youtube 영상을 재생하는 플레이어가 렌더링된 상황.*

